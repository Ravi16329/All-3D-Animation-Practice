<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://public-frontend-cos.metadl.com/mgx/img/favicon.png" type="image/png">
    <title>Immersive 3D Experience</title>
    <link rel="stylesheet" href="./style.css">
    <link rel="stylesheet" href="./fallback.css">
    <meta name="description" content="An immersive 3D web experience with interactive elements and modern design">
    
    <!-- Preload Three.js for better performance -->
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" as="script">
    <style>
        /* CSS Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --primary-color: #00d4ff;
    --secondary-color: #ff6b6b;
    --accent-color: #4ecdc4;
    --dark-bg: #0a0a0a;
    --light-text: #ffffff;
    --glass-bg: rgba(255, 255, 255, 0.1);
    --glass-border: rgba(255, 255, 255, 0.2);
    --shadow-color: rgba(0, 0, 0, 0.3);
    --gradient-primary: linear-gradient(135deg, var(--primary-color), var(--accent-color));
    --gradient-secondary: linear-gradient(135deg, var(--secondary-color), #ff8e8e);
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--dark-bg);
    color: var(--light-text);
    overflow: hidden;
    height: 100vh;
    position: relative;
}

/* Custom Scrollbar */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: var(--gradient-primary);
    border-radius: 4px;
    transition: all 0.3s ease;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--primary-color);
}

/* Firefox Scrollbar */
* {
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) rgba(255, 255, 255, 0.1);
}

/* Loading Screen */
.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    transition: opacity 0.5s ease-out;
}

.loading-content {
    text-align: center;
    max-width: 400px;
    padding: 2rem;
}

.loading-spinner {
    width: 60px;
    height: 60px;
    border: 3px solid rgba(255, 255, 255, 0.1);
    border-top: 3px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 2rem;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loading-bar {
    width: 100%;
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    margin: 1rem 0;
    overflow: hidden;
}

.loading-progress {
    height: 100%;
    background: var(--gradient-primary);
    border-radius: 2px;
    width: 0%;
    transition: width 0.3s ease;
}

.loading-content h2 {
    font-size: 1.5rem;
    margin-bottom: 1rem;
    background: var(--gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.loading-content p {
    opacity: 0.8;
    font-size: 0.9rem;
}

/* Canvas Container */
.canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#three-canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: grab;
}

#three-canvas:active {
    cursor: grabbing;
}

/* UI Overlay */
.ui-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
}

.ui-overlay > * {
    pointer-events: auto;
}

/* Navigation */
.main-nav {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding: 1.5rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(180deg, rgba(0, 0, 0, 0.8), transparent);
    backdrop-filter: blur(10px);
    z-index: 100;
}

.nav-brand h1 {
    font-size: 1.8rem;
    font-weight: 700;
    background: var(--gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.nav-controls {
    display: flex;
    gap: 1rem;
}

.control-btn {
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    color: var(--light-text);
    padding: 0.75rem;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    font-size: 1.2rem;
}

.control-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px var(--shadow-color);
}

/* Main Content */
.main-content {
    position: absolute;
    bottom: 2rem;
    left: 2rem;
    right: 2rem;
    max-width: 600px;
}

.hero-section {
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    border-radius: 20px;
    padding: 2.5rem;
    margin-bottom: 2rem;
    box-shadow: 0 20px 40px var(--shadow-color);
}

.hero-title {
    font-size: 3rem;
    font-weight: 800;
    margin-bottom: 1rem;
    background: var(--gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.2;
}

.hero-subtitle {
    font-size: 1.2rem;
    opacity: 0.9;
    margin-bottom: 2rem;
    line-height: 1.5;
}

.hero-actions {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
}

.cta-button {
    padding: 1rem 2rem;
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.cta-button.primary {
    background: var(--gradient-primary);
    color: white;
}

.cta-button.secondary {
    background: transparent;
    color: var(--light-text);
    border: 2px solid var(--primary-color);
}

.cta-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 10px 30px var(--shadow-color);
}

.cta-button.primary:hover {
    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
}

/* Features Section */
.features-section {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
}

.feature-card {
    background: var(--glass-bg);
    backdrop-filter: blur(15px);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    padding: 1.5rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
}

.feature-card:hover {
    transform: translateY(-5px);
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 0 15px 35px var(--shadow-color);
}

.feature-card h3 {
    font-size: 1.1rem;
    margin-bottom: 0.5rem;
    color: var(--primary-color);
}

.feature-card p {
    font-size: 0.9rem;
    opacity: 0.8;
    line-height: 1.4;
}

/* Performance Panel */
.performance-panel {
    position: absolute;
    top: 5rem;
    right: 2rem;
    width: 300px;
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: 0 20px 40px var(--shadow-color);
    transition: all 0.3s ease;
}

.performance-panel.hidden {
    opacity: 0;
    transform: translateX(100%);
    pointer-events: none;
}

.performance-panel h3 {
    margin-bottom: 1.5rem;
    color: var(--primary-color);
    font-size: 1.2rem;
}

.setting-group {
    margin-bottom: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.setting-group label {
    font-size: 0.9rem;
    opacity: 0.9;
}

.setting-group select,
.setting-group input[type="checkbox"] {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid var(--glass-border);
    border-radius: 6px;
    color: var(--light-text);
    padding: 0.5rem;
}

.performance-stats {
    border-top: 1px solid var(--glass-border);
    padding-top: 1rem;
    margin-top: 1.5rem;
}

.stat {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.stat-label {
    opacity: 0.8;
    font-size: 0.9rem;
}

.stat-value {
    color: var(--primary-color);
    font-weight: 600;
}

/* Responsive Design */
@media (max-width: 768px) {
    .main-nav {
        padding: 1rem;
    }
    
    .nav-brand h1 {
        font-size: 1.4rem;
    }
    
    .main-content {
        bottom: 1rem;
        left: 1rem;
        right: 1rem;
    }
    
    .hero-section {
        padding: 1.5rem;
    }
    
    .hero-title {
        font-size: 2rem;
    }
    
    .hero-subtitle {
        font-size: 1rem;
    }
    
    .hero-actions {
        flex-direction: column;
    }
    
    .cta-button {
        width: 100%;
        text-align: center;
    }
    
    .features-section {
        grid-template-columns: 1fr;
    }
    
    .performance-panel {
        right: 1rem;
        width: calc(100% - 2rem);
        max-width: 300px;
    }
}

@media (max-width: 480px) {
    .hero-title {
        font-size: 1.8rem;
    }
    
    .nav-controls {
        gap: 0.5rem;
    }
    
    .control-btn {
        padding: 0.5rem;
        font-size: 1rem;
    }
}

/* Animation Classes */
.fade-in {
    animation: fadeIn 0.8s ease-out;
}

.slide-up {
    animation: slideUp 0.6s ease-out;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Accessibility */
@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
    
    .loading-spinner {
        animation: none;
    }
}

/* Focus States */
.control-btn:focus,
.cta-button:focus,
.feature-card:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
}

/* High Contrast Mode */
@media (prefers-contrast: high) {
    :root {
        --glass-bg: rgba(255, 255, 255, 0.2);
        --glass-border: rgba(255, 255, 255, 0.4);
    }
}
    </style>
    <style>
        /* CSS Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --primary-color: #00d4ff;
    --secondary-color: #ff6b6b;
    --accent-color: #4ecdc4;
    --dark-bg: #0a0a0a;
    --light-text: #ffffff;
    --glass-bg: rgba(255, 255, 255, 0.1);
    --glass-border: rgba(255, 255, 255, 0.2);
    --shadow-color: rgba(0, 0, 0, 0.3);
    --gradient-primary: linear-gradient(135deg, var(--primary-color), var(--accent-color));
    --gradient-secondary: linear-gradient(135deg, var(--secondary-color), #ff8e8e);
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--dark-bg);
    color: var(--light-text);
    overflow: hidden;
    height: 100vh;
    position: relative;
}

/* Custom Scrollbar */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: var(--gradient-primary);
    border-radius: 4px;
    transition: all 0.3s ease;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--primary-color);
}

/* Firefox Scrollbar */
* {
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) rgba(255, 255, 255, 0.1);
}

/* Loading Screen */
.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    transition: opacity 0.5s ease-out;
}

.loading-content {
    text-align: center;
    max-width: 400px;
    padding: 2rem;
}

.loading-spinner {
    width: 60px;
    height: 60px;
    border: 3px solid rgba(255, 255, 255, 0.1);
    border-top: 3px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 2rem;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loading-bar {
    width: 100%;
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    margin: 1rem 0;
    overflow: hidden;
}

.loading-progress {
    height: 100%;
    background: var(--gradient-primary);
    border-radius: 2px;
    width: 0%;
    transition: width 0.3s ease;
}

.loading-content h2 {
    font-size: 1.5rem;
    margin-bottom: 1rem;
    background: var(--gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.loading-content p {
    opacity: 0.8;
    font-size: 0.9rem;
}

/* Canvas Container */
.canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#three-canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: grab;
}

#three-canvas:active {
    cursor: grabbing;
}

/* UI Overlay */
.ui-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
}

.ui-overlay > * {
    pointer-events: auto;
}

/* Navigation */
.main-nav {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding: 1.5rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(180deg, rgba(0, 0, 0, 0.8), transparent);
    backdrop-filter: blur(10px);
    z-index: 100;
}

.nav-brand h1 {
    font-size: 1.8rem;
    font-weight: 700;
    background: var(--gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.nav-controls {
    display: flex;
    gap: 1rem;
}

.control-btn {
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    color: var(--light-text);
    padding: 0.75rem;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    font-size: 1.2rem;
}

.control-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px var(--shadow-color);
}

/* Main Content */
.main-content {
    position: absolute;
    bottom: 2rem;
    left: 2rem;
    right: 2rem;
    max-width: 600px;
}

.hero-section {
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    border-radius: 20px;
    padding: 2.5rem;
    margin-bottom: 2rem;
    box-shadow: 0 20px 40px var(--shadow-color);
}

.hero-title {
    font-size: 3rem;
    font-weight: 800;
    margin-bottom: 1rem;
    background: var(--gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.2;
}

.hero-subtitle {
    font-size: 1.2rem;
    opacity: 0.9;
    margin-bottom: 2rem;
    line-height: 1.5;
}

.hero-actions {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
}

.cta-button {
    padding: 1rem 2rem;
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.cta-button.primary {
    background: var(--gradient-primary);
    color: white;
}

.cta-button.secondary {
    background: transparent;
    color: var(--light-text);
    border: 2px solid var(--primary-color);
}

.cta-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 10px 30px var(--shadow-color);
}

.cta-button.primary:hover {
    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
}

/* Features Section */
.features-section {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
}

.feature-card {
    background: var(--glass-bg);
    backdrop-filter: blur(15px);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    padding: 1.5rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
}

.feature-card:hover {
    transform: translateY(-5px);
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 0 15px 35px var(--shadow-color);
}

.feature-card h3 {
    font-size: 1.1rem;
    margin-bottom: 0.5rem;
    color: var(--primary-color);
}

.feature-card p {
    font-size: 0.9rem;
    opacity: 0.8;
    line-height: 1.4;
}

/* Performance Panel */
.performance-panel {
    position: absolute;
    top: 5rem;
    right: 2rem;
    width: 300px;
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: 0 20px 40px var(--shadow-color);
    transition: all 0.3s ease;
}

.performance-panel.hidden {
    opacity: 0;
    transform: translateX(100%);
    pointer-events: none;
}

.performance-panel h3 {
    margin-bottom: 1.5rem;
    color: var(--primary-color);
    font-size: 1.2rem;
}

.setting-group {
    margin-bottom: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.setting-group label {
    font-size: 0.9rem;
    opacity: 0.9;
}

.setting-group select,
.setting-group input[type="checkbox"] {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid var(--glass-border);
    border-radius: 6px;
    color: var(--light-text);
    padding: 0.5rem;
}

.performance-stats {
    border-top: 1px solid var(--glass-border);
    padding-top: 1rem;
    margin-top: 1.5rem;
}

.stat {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.stat-label {
    opacity: 0.8;
    font-size: 0.9rem;
}

.stat-value {
    color: var(--primary-color);
    font-weight: 600;
}

/* Responsive Design */
@media (max-width: 768px) {
    .main-nav {
        padding: 1rem;
    }
    
    .nav-brand h1 {
        font-size: 1.4rem;
    }
    
    .main-content {
        bottom: 1rem;
        left: 1rem;
        right: 1rem;
    }
    
    .hero-section {
        padding: 1.5rem;
    }
    
    .hero-title {
        font-size: 2rem;
    }
    
    .hero-subtitle {
        font-size: 1rem;
    }
    
    .hero-actions {
        flex-direction: column;
    }
    
    .cta-button {
        width: 100%;
        text-align: center;
    }
    
    .features-section {
        grid-template-columns: 1fr;
    }
    
    .performance-panel {
        right: 1rem;
        width: calc(100% - 2rem);
        max-width: 300px;
    }
}

@media (max-width: 480px) {
    .hero-title {
        font-size: 1.8rem;
    }
    
    .nav-controls {
        gap: 0.5rem;
    }
    
    .control-btn {
        padding: 0.5rem;
        font-size: 1rem;
    }
}

/* Animation Classes */
.fade-in {
    animation: fadeIn 0.8s ease-out;
}

.slide-up {
    animation: slideUp 0.6s ease-out;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Accessibility */
@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
    
    .loading-spinner {
        animation: none;
    }
}

/* Focus States */
.control-btn:focus,
.cta-button:focus,
.feature-card:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
}

/* High Contrast Mode */
@media (prefers-contrast: high) {
    :root {
        --glass-bg: rgba(255, 255, 255, 0.2);
        --glass-border: rgba(255, 255, 255, 0.4);
    }
}
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <h2>Loading 3D Experience</h2>
            <div class="loading-bar">
                <div class="loading-progress" id="loading-progress"></div>
            </div>
            <p id="loading-text">Initializing...</p>
        </div>
    </div>

    <!-- Main 3D Canvas Container -->
    <div id="canvas-container" class="canvas-container">
        <canvas id="three-canvas"></canvas>
    </div>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <!-- Navigation -->
        <nav class="main-nav">
            <div class="nav-brand">
                <h1>3D Experience</h1>
            </div>
            <div class="nav-controls">
                <button id="fullscreen-btn" class="control-btn" aria-label="Toggle Fullscreen">
                    <span class="icon">⛶</span>
                </button>
                <button id="performance-btn" class="control-btn" aria-label="Performance Settings">
                    <span class="icon">⚙</span>
                </button>
            </div>
        </nav>

        

        <!-- Performance Panel -->
        <div id="performance-panel" class="performance-panel hidden">
            <h3>Performance Settings</h3>
            <div class="setting-group">
                <label for="quality-select">Render Quality:</label>
                <select id="quality-select">
                    <option value="high">High (Desktop)</option>
                    <option value="medium" selected>Medium (Recommended)</option>
                    <option value="low">Low (Mobile)</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="particles-toggle">Particle Effects:</label>
                <input type="checkbox" id="particles-toggle" checked>
            </div>
            <div class="setting-group">
                <label for="shadows-toggle">Shadows:</label>
                <input type="checkbox" id="shadows-toggle" checked>
            </div>
            <div class="performance-stats">
                <div class="stat">
                    <span class="stat-label">FPS:</span>
                    <span id="fps-counter" class="stat-value">60</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Triangles:</span>
                    <span id="triangle-counter" class="stat-value">0</span>
                </div>
            </div>
        </div>
    </div>

    

    <!-- Scripts -->
     <script>
        // Performance monitoring and optimization utilities
class PerformanceManager {
    constructor() {
        this.fps = 0;
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fpsHistory = [];
        this.isLowPerformanceDevice = false;
        this.renderQuality = 'medium';
        this.particlesEnabled = true;
        this.shadowsEnabled = true;
        
        this.detectDeviceCapabilities();
        this.initializeSettings();
    }

    detectDeviceCapabilities() {
        // Check device memory (if available)
        const memory = navigator.deviceMemory || 4; // Default to 4GB if not available
        
        // Check hardware concurrency
        const cores = navigator.hardwareConcurrency || 4;
        
        // Check if mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Check WebGL capabilities
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            this.showFallbackContent();
            return;
        }

        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : '';
        
        // Determine if this is a low-performance device
        this.isLowPerformanceDevice = (
            memory < 4 || 
            cores < 4 || 
            isMobile || 
            renderer.includes('Intel') ||
            renderer.includes('Mali') ||
            renderer.includes('Adreno')
        );

        // Set initial quality based on device capabilities
        if (this.isLowPerformanceDevice) {
            this.renderQuality = 'low';
            this.particlesEnabled = false;
            this.shadowsEnabled = false;
        }

        console.log('Device capabilities detected:', {
            memory,
            cores,
            isMobile,
            renderer,
            isLowPerformance: this.isLowPerformanceDevice
        });
    }

    initializeSettings() {
        // Load saved settings from localStorage
        const savedSettings = localStorage.getItem('3d-performance-settings');
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                this.renderQuality = settings.quality || this.renderQuality;
                this.particlesEnabled = settings.particles !== undefined ? settings.particles : this.particlesEnabled;
                this.shadowsEnabled = settings.shadows !== undefined ? settings.shadows : this.shadowsEnabled;
            } catch (e) {
                console.warn('Failed to load performance settings:', e);
            }
        }
    }

    saveSettings() {
        const settings = {
            quality: this.renderQuality,
            particles: this.particlesEnabled,
            shadows: this.shadowsEnabled
        };
        localStorage.setItem('3d-performance-settings', JSON.stringify(settings));
    }

    updateFPS(deltaTime) {
        this.frameCount++;
        const currentTime = performance.now();
        
        if (currentTime - this.lastTime >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
            this.fpsHistory.push(this.fps);
            
            // Keep only last 10 FPS readings
            if (this.fpsHistory.length > 10) {
                this.fpsHistory.shift();
            }
            
            // Auto-adjust quality if FPS is consistently low
            this.autoAdjustQuality();
            
            // Update UI
            this.updateFPSDisplay();
            
            this.frameCount = 0;
            this.lastTime = currentTime;
        }
    }

    autoAdjustQuality() {
        if (this.fpsHistory.length < 5) return;
        
        const averageFPS = this.fpsHistory.reduce((sum, fps) => sum + fps, 0) / this.fpsHistory.length;
        
        // If FPS is consistently below 30, reduce quality
        if (averageFPS < 30 && this.renderQuality !== 'low') {
            console.log('Auto-reducing quality due to low FPS:', averageFPS);
            
            if (this.renderQuality === 'high') {
                this.setRenderQuality('medium');
            } else if (this.renderQuality === 'medium') {
                this.setRenderQuality('low');
            }
            
            // Also disable expensive features
            if (averageFPS < 20) {
                this.particlesEnabled = false;
                this.shadowsEnabled = false;
            }
            
            this.saveSettings();
        }
        
        // If FPS is consistently above 50, we could increase quality
        else if (averageFPS > 50 && this.renderQuality === 'low' && !this.isLowPerformanceDevice) {
            console.log('Auto-increasing quality due to good FPS:', averageFPS);
            this.setRenderQuality('medium');
            this.saveSettings();
        }
    }

    setRenderQuality(quality) {
        this.renderQuality = quality;
        
        // Update UI
        const qualitySelect = document.getElementById('quality-select');
        if (qualitySelect) {
            qualitySelect.value = quality;
        }
        
        // Dispatch event for 3D scene to update
        window.dispatchEvent(new CustomEvent('qualityChanged', { 
            detail: { quality } 
        }));
    }

    updateFPSDisplay() {
        const fpsCounter = document.getElementById('fps-counter');
        if (fpsCounter) {
            fpsCounter.textContent = this.fps;
            
            // Color code based on FPS
            if (this.fps >= 50) {
                fpsCounter.style.color = '#4ecdc4'; // Good
            } else if (this.fps >= 30) {
                fpsCounter.style.color = '#ffd93d'; // OK
            } else {
                fpsCounter.style.color = '#ff6b6b'; // Poor
            }
        }
    }

    updateTriangleCount(count) {
        const triangleCounter = document.getElementById('triangle-counter');
        if (triangleCounter) {
            triangleCounter.textContent = count.toLocaleString();
        }
    }

    showFallbackContent() {
        console.warn('WebGL not supported, showing fallback content');
        
        // Hide loading screen and 3D content
        const loadingScreen = document.getElementById('loading-screen');
        const canvasContainer = document.getElementById('canvas-container');
        const uiOverlay = document.querySelector('.ui-overlay');
        const fallbackContent = document.getElementById('fallback-content');
        
        if (loadingScreen) loadingScreen.style.display = 'none';
        if (canvasContainer) canvasContainer.style.display = 'none';
        if (uiOverlay) uiOverlay.style.display = 'none';
        if (fallbackContent) {
            fallbackContent.classList.remove('hidden');
            fallbackContent.style.display = 'block';
        }
    }

    getQualitySettings() {
        const settings = {
            low: {
                pixelRatio: Math.min(window.devicePixelRatio, 1),
                antialias: false,
                shadows: false,
                particles: false,
                maxParticles: 0,
                renderDistance: 50,
                animationQuality: 0.5
            },
            medium: {
                pixelRatio: Math.min(window.devicePixelRatio, 1.5),
                antialias: true,
                shadows: this.shadowsEnabled,
                particles: this.particlesEnabled,
                maxParticles: 1000,
                renderDistance: 100,
                animationQuality: 0.75
            },
            high: {
                pixelRatio: Math.min(window.devicePixelRatio, 2),
                antialias: true,
                shadows: this.shadowsEnabled,
                particles: this.particlesEnabled,
                maxParticles: 2000,
                renderDistance: 150,
                animationQuality: 1.0
            }
        };
        
        return settings[this.renderQuality] || settings.medium;
    }

    // Memory management
    disposeObject(object) {
        if (object.geometry) {
            object.geometry.dispose();
        }
        
        if (object.material) {
            if (Array.isArray(object.material)) {
                object.material.forEach(material => {
                    this.disposeMaterial(material);
                });
            } else {
                this.disposeMaterial(object.material);
            }
        }
        
        if (object.texture) {
            object.texture.dispose();
        }
    }

    disposeMaterial(material) {
        if (material.map) material.map.dispose();
        if (material.normalMap) material.normalMap.dispose();
        if (material.roughnessMap) material.roughnessMap.dispose();
        if (material.metalnessMap) material.metalnessMap.dispose();
        if (material.envMap) material.envMap.dispose();
        material.dispose();
    }

    // Throttle function for performance-sensitive operations
    throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        }
    }

    // Debounce function for resize events
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
}

// Export for use in other modules
window.PerformanceManager = PerformanceManager;
     </script>
     <script>
        // 3D Scene Management and Three.js Implementation
class Scene3D {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.animationId = null;
        this.clock = new THREE.Clock();
        
        // Scene objects
        this.geometricObjects = [];
        this.particleSystem = null;
        this.environmentObjects = [];
        this.lights = [];
        
        // Animation states
        this.currentScene = 'geometric';
        this.isAnimating = false;
        this.mousePosition = { x: 0, y: 0 };
        
        // Performance
        this.performanceManager = new PerformanceManager();
        
        this.init();
        this.setupEventListeners();
    }

    init() {
        this.setupRenderer();
        this.setupCamera();
        this.setupLights();
        this.createGeometricScene();
        this.createParticleSystem();
        this.createEnvironment();
        this.setupControls();
        this.startAnimation();
    }

    setupRenderer() {
        const canvas = document.getElementById('three-canvas');
        const qualitySettings = this.performanceManager.getQualitySettings();
        
        this.renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: qualitySettings.antialias,
            alpha: true,
            powerPreference: 'high-performance'
        });
        
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(qualitySettings.pixelRatio);
        this.renderer.setClearColor(0x000000, 0);
        this.renderer.shadowMap.enabled = qualitySettings.shadows;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.2;
    }

    setupCamera() {
        this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        this.camera.position.set(0, 5, 10);
        
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x000000, 50, 200);
    }

    setupLights() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        this.scene.add(ambientLight);
        this.lights.push(ambientLight);

        // Main directional light
        const directionalLight = new THREE.DirectionalLight(0x00d4ff, 1);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = this.performanceManager.getQualitySettings().shadows;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        this.scene.add(directionalLight);
        this.lights.push(directionalLight);

        // Accent lights
        const accentLight1 = new THREE.PointLight(0xff6b6b, 0.8, 30);
        accentLight1.position.set(-10, 5, -10);
        this.scene.add(accentLight1);
        this.lights.push(accentLight1);

        const accentLight2 = new THREE.PointLight(0x4ecdc4, 0.6, 25);
        accentLight2.position.set(10, -5, 10);
        this.scene.add(accentLight2);
        this.lights.push(accentLight2);
    }

    createGeometricScene() {
        const geometries = [
            new THREE.BoxGeometry(2, 2, 2),
            new THREE.SphereGeometry(1.5, 32, 32),
            new THREE.ConeGeometry(1, 3, 8),
            new THREE.TorusGeometry(1.5, 0.5, 16, 100),
            new THREE.OctahedronGeometry(1.8),
            new THREE.DodecahedronGeometry(1.5)
        ];

        const materials = [
            new THREE.MeshPhysicalMaterial({
                color: 0x00d4ff,
                metalness: 0.7,
                roughness: 0.2,
                transparent: true,
                opacity: 0.8
            }),
            new THREE.MeshPhysicalMaterial({
                color: 0xff6b6b,
                metalness: 0.3,
                roughness: 0.4,
                transparent: true,
                opacity: 0.9
            }),
            new THREE.MeshPhysicalMaterial({
                color: 0x4ecdc4,
                metalness: 0.5,
                roughness: 0.3,
                transparent: true,
                opacity: 0.7
            })
        ];

        // Create geometric objects in a spiral pattern
        for (let i = 0; i < 12; i++) {
            const geometry = geometries[i % geometries.length];
            const material = materials[i % materials.length].clone();
            const mesh = new THREE.Mesh(geometry, material);

            // Position in spiral
            const angle = (i / 12) * Math.PI * 2;
            const radius = 8 + (i * 0.5);
            mesh.position.x = Math.cos(angle) * radius;
            mesh.position.z = Math.sin(angle) * radius;
            mesh.position.y = Math.sin(i * 0.5) * 3;

            // Random rotation
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;
            mesh.rotation.z = Math.random() * Math.PI;

            mesh.castShadow = true;
            mesh.receiveShadow = true;

            // Store animation data
            mesh.userData = {
                originalPosition: mesh.position.clone(),
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                floatSpeed: Math.random() * 0.01 + 0.005,
                floatOffset: Math.random() * Math.PI * 2
            };

            this.scene.add(mesh);
            this.geometricObjects.push(mesh);
        }
    }

    createParticleSystem() {
        const qualitySettings = this.performanceManager.getQualitySettings();
        
        if (!qualitySettings.particles) {
            return;
        }

        const particleCount = qualitySettings.maxParticles;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        const colorPalette = [
            new THREE.Color(0x00d4ff),
            new THREE.Color(0xff6b6b),
            new THREE.Color(0x4ecdc4),
            new THREE.Color(0xffd93d)
        ];

        for (let i = 0; i < particleCount; i++) {
            // Position
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

            // Color
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;

            // Size
            sizes[i] = Math.random() * 3 + 1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                attribute float size;
                varying vec3 vColor;
                uniform float time;
                
                void main() {
                    vColor = color;
                    vec3 pos = position;
                    
                    // Add some movement
                    pos.x += sin(time * 0.5 + position.y * 0.01) * 2.0;
                    pos.y += cos(time * 0.3 + position.x * 0.01) * 1.5;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                
                void main() {
                    float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
                    float alpha = 1.0 - smoothstep(0.0, 0.5, distanceToCenter);
                    
                    gl_FragColor = vec4(vColor, alpha * 0.8);
                }
            `,
            transparent: true,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        this.particleSystem = new THREE.Points(geometry, material);
        this.scene.add(this.particleSystem);
    }

    createEnvironment() {
        // Create a ground plane
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshLambertMaterial({
            color: 0x1a1a2e,
            transparent: true,
            opacity: 0.3
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -10;
        ground.receiveShadow = true;
        this.scene.add(ground);
        this.environmentObjects.push(ground);

        // Create floating rings
        for (let i = 0; i < 5; i++) {
            const ringGeometry = new THREE.TorusGeometry(15 + i * 5, 0.5, 8, 50);
            const ringMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x00d4ff,
                metalness: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.3
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.y = i * 8 - 20;
            ring.rotation.x = Math.PI / 2;
            
            ring.userData = {
                rotationSpeed: 0.005 + i * 0.001,
                originalY: ring.position.y
            };
            
            this.scene.add(ring);
            this.environmentObjects.push(ring);
        }
    }

    setupControls() {
        // Simple mouse/touch controls for camera
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;

        const canvas = this.renderer.domElement;

        // Mouse events
        canvas.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        canvas.addEventListener('mousemove', (event) => {
            this.mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                this.camera.position.x += deltaX * 0.01;
                this.camera.position.y -= deltaY * 0.01;
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Wheel zoom
        canvas.addEventListener('wheel', (event) => {
            const zoomSpeed = 0.1;
            this.camera.position.z += event.deltaY * zoomSpeed;
            this.camera.position.z = Math.max(5, Math.min(50, this.camera.position.z));
        });

        // Touch events for mobile
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }
        });

        canvas.addEventListener('touchmove', (event) => {
            event.preventDefault();
            
            if (event.touches.length === 1) {
                const deltaX = event.touches[0].clientX - touchStartX;
                const deltaY = event.touches[0].clientY - touchStartY;
                
                this.camera.position.x += deltaX * 0.01;
                this.camera.position.y -= deltaY * 0.01;
                
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }
        });
    }

    setupEventListeners() {
        // Window resize
        window.addEventListener('resize', this.performanceManager.debounce(() => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }, 250));

        // Quality change events
        window.addEventListener('qualityChanged', (event) => {
            this.updateQuality(event.detail.quality);
        });

        // Scene switching
        document.addEventListener('click', (event) => {
            if (event.target.classList.contains('feature-card')) {
                const sceneType = event.target.dataset.scene;
                this.switchScene(sceneType);
            }
        });
    }

    updateQuality(quality) {
        const qualitySettings = this.performanceManager.getQualitySettings();
        
        // Update renderer settings
        this.renderer.setPixelRatio(qualitySettings.pixelRatio);
        this.renderer.shadowMap.enabled = qualitySettings.shadows;
        
        // Update particle system
        if (this.particleSystem) {
            this.particleSystem.visible = qualitySettings.particles;
        }
        
        // Update materials based on quality
        this.geometricObjects.forEach(obj => {
            if (obj.material) {
                obj.material.transparent = quality !== 'low';
                obj.castShadow = qualitySettings.shadows;
                obj.receiveShadow = qualitySettings.shadows;
            }
        });
    }

    switchScene(sceneType) {
        this.currentScene = sceneType;
        
        // Animate camera to different positions based on scene
        const targetPositions = {
            geometric: { x: 0, y: 5, z: 10 },
            particles: { x: 15, y: 10, z: 15 },
            environment: { x: -10, y: 20, z: 25 }
        };
        
        const target = targetPositions[sceneType] || targetPositions.geometric;
        this.animateCameraTo(target);
    }

    animateCameraTo(targetPosition) {
        if (this.isAnimating) return;
        
        this.isAnimating = true;
        const startPosition = this.camera.position.clone();
        const duration = 2000; // 2 seconds
        const startTime = Date.now();
        
        const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Easing function (ease-in-out)
            const easeProgress = progress < 0.5 
                ? 2 * progress * progress 
                : 1 - Math.pow(-2 * progress + 2, 3) / 2;
            
            this.camera.position.lerpVectors(startPosition, new THREE.Vector3(
                targetPosition.x,
                targetPosition.y,
                targetPosition.z
            ), easeProgress);
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                this.isAnimating = false;
            }
        };
        
        animate();
    }

    animate() {
        this.animationId = requestAnimationFrame(() => this.animate());
        
        const deltaTime = this.clock.getDelta();
        const elapsedTime = this.clock.getElapsedTime();
        
        // Update performance monitoring
        this.performanceManager.updateFPS(deltaTime);
        
        // Animate geometric objects
        this.geometricObjects.forEach((obj, index) => {
            // Rotation
            obj.rotation.x += obj.userData.rotationSpeed.x;
            obj.rotation.y += obj.userData.rotationSpeed.y;
            obj.rotation.z += obj.userData.rotationSpeed.z;
            
            // Floating motion
            obj.position.y = obj.userData.originalPosition.y + 
                Math.sin(elapsedTime * obj.userData.floatSpeed + obj.userData.floatOffset) * 2;
            
            // Mouse interaction
            const mouseInfluence = 0.1;
            obj.position.x = obj.userData.originalPosition.x + this.mousePosition.x * mouseInfluence;
        });
        
        // Animate particle system
        if (this.particleSystem && this.particleSystem.material.uniforms) {
            this.particleSystem.material.uniforms.time.value = elapsedTime;
            this.particleSystem.rotation.y += 0.001;
        }
        
        // Animate environment objects
        this.environmentObjects.forEach(obj => {
            if (obj.userData.rotationSpeed) {
                obj.rotation.z += obj.userData.rotationSpeed;
            }
        });
        
        // Camera auto-rotation when not interacting
        if (!this.isAnimating) {
            this.camera.position.x += Math.sin(elapsedTime * 0.1) * 0.01;
            this.camera.position.z += Math.cos(elapsedTime * 0.1) * 0.01;
        }
        
        // Always look at scene center
        this.camera.lookAt(0, 0, 0);
        
        // Update triangle count for performance monitoring
        let triangleCount = 0;
        this.scene.traverse((object) => {
            if (object.geometry) {
                triangleCount += object.geometry.attributes.position ? 
                    object.geometry.attributes.position.count / 3 : 0;
            }
        });
        this.performanceManager.updateTriangleCount(triangleCount);
        
        // Render
        this.renderer.render(this.scene, this.camera);
    }

    startAnimation() {
        this.animate();
    }

    stopAnimation() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }

    dispose() {
        this.stopAnimation();
        
        // Dispose of all objects
        [...this.geometricObjects, ...this.environmentObjects].forEach(obj => {
            this.performanceManager.disposeObject(obj);
        });
        
        if (this.particleSystem) {
            this.performanceManager.disposeObject(this.particleSystem);
        }
        
        // Dispose renderer
        this.renderer.dispose();
    }
}

// Export for use in main script
window.Scene3D = Scene3D;
     </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main application script
class App3D {
    constructor() {
        this.scene3D = null;
        this.isLoaded = false;
        this.loadingProgress = 0;
        
        this.init();
    }

    async init() {
        // Check WebGL support
        if (!this.checkWebGLSupport()) {
            this.showFallback();
            return;
        }

        // Show loading screen
        this.showLoadingScreen();
        
        // Simulate loading process
        await this.simulateLoading();
        
        // Initialize 3D scene
        this.initialize3DScene();
        
        // Setup UI event listeners
        this.setupUIEventListeners();
        
        // Hide loading screen and show main content
        this.hideLoadingScreen();
        
        this.isLoaded = true;
        console.log('3D Application initialized successfully');
    }

    checkWebGLSupport() {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            return !!gl;
        } catch (e) {
            return false;
        }
    }

    showFallback() {
        const loadingScreen = document.getElementById('loading-screen');
        const canvasContainer = document.getElementById('canvas-container');
        const uiOverlay = document.querySelector('.ui-overlay');
        const fallbackContent = document.getElementById('fallback-content');
        
        if (loadingScreen) loadingScreen.style.display = 'none';
        if (canvasContainer) canvasContainer.style.display = 'none';
        if (uiOverlay) uiOverlay.style.display = 'none';
        if (fallbackContent) {
            fallbackContent.classList.remove('hidden');
            fallbackContent.style.display = 'block';
        }
    }

    showLoadingScreen() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.style.display = 'flex';
        }
    }

    async simulateLoading() {
        const loadingText = document.getElementById('loading-text');
        const loadingProgress = document.getElementById('loading-progress');
        
        const loadingSteps = [
            { text: 'Initializing WebGL...', duration: 300 },
            { text: 'Loading 3D models...', duration: 500 },
            { text: 'Setting up shaders...', duration: 400 },
            { text: 'Creating particle systems...', duration: 600 },
            { text: 'Optimizing performance...', duration: 300 },
            { text: 'Finalizing scene...', duration: 200 }
        ];

        let currentProgress = 0;
        const totalSteps = loadingSteps.length;

        for (let i = 0; i < loadingSteps.length; i++) {
            const step = loadingSteps[i];
            
            if (loadingText) {
                loadingText.textContent = step.text;
            }
            
            // Animate progress bar
            const targetProgress = ((i + 1) / totalSteps) * 100;
            await this.animateProgress(currentProgress, targetProgress, step.duration);
            currentProgress = targetProgress;
            
            // Wait for step duration
            await new Promise(resolve => setTimeout(resolve, step.duration));
        }
    }

    animateProgress(start, end, duration) {
        return new Promise(resolve => {
            const loadingProgress = document.getElementById('loading-progress');
            if (!loadingProgress) {
                resolve();
                return;
            }

            const startTime = Date.now();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const currentValue = start + (end - start) * progress;
                loadingProgress.style.width = `${currentValue}%`;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    resolve();
                }
            };
            
            animate();
        });
    }

    initialize3DScene() {
        try {
            this.scene3D = new Scene3D();
        } catch (error) {
            console.error('Failed to initialize 3D scene:', error);
            this.showFallback();
        }
    }

    setupUIEventListeners() {
        // Fullscreen button
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', this.toggleFullscreen.bind(this));
        }

        // Performance button
        const performanceBtn = document.getElementById('performance-btn');
        const performancePanel = document.getElementById('performance-panel');
        if (performanceBtn && performancePanel) {
            performanceBtn.addEventListener('click', () => {
                performancePanel.classList.toggle('hidden');
            });
        }

        // Performance settings
        this.setupPerformanceControls();

        // CTA buttons
        const startTourBtn = document.getElementById('start-tour-btn');
        const exploreBtn = document.getElementById('explore-btn');
        
        if (startTourBtn) {
            startTourBtn.addEventListener('click', this.startTour.bind(this));
        }
        
        if (exploreBtn) {
            exploreBtn.addEventListener('click', this.startExploration.bind(this));
        }

        // Feature cards
        const featureCards = document.querySelectorAll('.feature-card');
        featureCards.forEach(card => {
            card.addEventListener('click', () => {
                // Remove active class from all cards
                featureCards.forEach(c => c.classList.remove('active'));
                // Add active class to clicked card
                card.classList.add('active');
                
                // Add visual feedback
                this.showCardFeedback(card);
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));

        // Close performance panel when clicking outside
        document.addEventListener('click', (event) => {
            const performancePanel = document.getElementById('performance-panel');
            const performanceBtn = document.getElementById('performance-btn');
            
            if (performancePanel && !performancePanel.contains(event.target) && 
                performanceBtn && !performanceBtn.contains(event.target)) {
                performancePanel.classList.add('hidden');
            }
        });
    }

    setupPerformanceControls() {
        const qualitySelect = document.getElementById('quality-select');
        const particlesToggle = document.getElementById('particles-toggle');
        const shadowsToggle = document.getElementById('shadows-toggle');

        if (qualitySelect) {
            qualitySelect.addEventListener('change', (event) => {
                if (this.scene3D && this.scene3D.performanceManager) {
                    this.scene3D.performanceManager.setRenderQuality(event.target.value);
                    this.scene3D.performanceManager.saveSettings();
                }
            });
        }

        if (particlesToggle) {
            particlesToggle.addEventListener('change', (event) => {
                if (this.scene3D && this.scene3D.performanceManager) {
                    this.scene3D.performanceManager.particlesEnabled = event.target.checked;
                    this.scene3D.performanceManager.saveSettings();
                    
                    // Update particle system visibility
                    if (this.scene3D.particleSystem) {
                        this.scene3D.particleSystem.visible = event.target.checked;
                    }
                }
            });
        }

        if (shadowsToggle) {
            shadowsToggle.addEventListener('change', (event) => {
                if (this.scene3D && this.scene3D.performanceManager) {
                    this.scene3D.performanceManager.shadowsEnabled = event.target.checked;
                    this.scene3D.performanceManager.saveSettings();
                    
                    // Update renderer shadows
                    if (this.scene3D.renderer) {
                        this.scene3D.renderer.shadowMap.enabled = event.target.checked;
                    }
                }
            });
        }
    }

    toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.warn('Could not enter fullscreen mode:', err);
            });
        } else {
            document.exitFullscreen();
        }
    }

    startTour() {
        if (!this.scene3D) return;
        
        console.log('Starting interactive tour...');
        
        // Create tour sequence
        const tourStops = [
            { scene: 'geometric', duration: 3000, message: 'Welcome to our geometric world!' },
            { scene: 'particles', duration: 3000, message: 'Experience dynamic particle systems!' },
            { scene: 'environment', duration: 3000, message: 'Explore immersive environments!' }
        ];
        
        this.runTour(tourStops, 0);
    }

    runTour(tourStops, currentIndex) {
        if (currentIndex >= tourStops.length) {
            console.log('Tour completed!');
            this.showTourComplete();
            return;
        }
        
        const stop = tourStops[currentIndex];
        
        // Show tour message
        this.showTourMessage(stop.message);
        
        // Switch to scene
        this.scene3D.switchScene(stop.scene);
        
        // Continue to next stop
        setTimeout(() => {
            this.runTour(tourStops, currentIndex + 1);
        }, stop.duration);
    }

    showTourMessage(message) {
        // Create or update tour message overlay
        let tourMessage = document.getElementById('tour-message');
        
        if (!tourMessage) {
            tourMessage = document.createElement('div');
            tourMessage.id = 'tour-message';
            tourMessage.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 2rem;
                border-radius: 12px;
                font-size: 1.2rem;
                text-align: center;
                z-index: 1000;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
            `;
            document.body.appendChild(tourMessage);
        }
        
        tourMessage.textContent = message;
        tourMessage.classList.add('fade-in');
        
        // Remove message after 2.5 seconds
        setTimeout(() => {
            tourMessage.style.opacity = '0';
        }, 2500);
    }

    showTourComplete() {
        this.showTourMessage('Tour completed! Feel free to explore on your own.');
    }

    startExploration() {
        console.log('Starting free exploration mode...');
        
        // Hide main content temporarily to focus on 3D scene
        const mainContent = document.querySelector('.main-content');
        if (mainContent) {
            mainContent.style.opacity = '0.3';
            mainContent.style.pointerEvents = 'none';
            
            // Show exploration instructions
            this.showTourMessage('Use mouse/touch to explore the 3D world. Click anywhere to exit exploration mode.');
            
            // Set up exit exploration
            const exitExploration = () => {
                mainContent.style.opacity = '1';
                mainContent.style.pointerEvents = 'auto';
                document.removeEventListener('click', exitExploration);
            };
            
            setTimeout(() => {
                document.addEventListener('click', exitExploration);
            }, 3000);
        }
    }

    showCardFeedback(card) {
        // Add ripple effect
        const ripple = document.createElement('div');
        ripple.style.cssText = `
            position: absolute;
            border-radius: 50%;
            background: rgba(0, 212, 255, 0.3);
            transform: scale(0);
            animation: ripple 0.6s linear;
            pointer-events: none;
        `;
        
        const rect = card.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        ripple.style.width = ripple.style.height = size + 'px';
        ripple.style.left = '50%';
        ripple.style.top = '50%';
        ripple.style.marginLeft = -size / 2 + 'px';
        ripple.style.marginTop = -size / 2 + 'px';
        
        card.style.position = 'relative';
        card.appendChild(ripple);
        
        setTimeout(() => {
            ripple.remove();
        }, 600);
    }

    handleKeyboardShortcuts(event) {
        // Prevent shortcuts when typing in inputs
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT') {
            return;
        }
        
        switch (event.key.toLowerCase()) {
            case 'f':
                event.preventDefault();
                this.toggleFullscreen();
                break;
            case 'p':
                event.preventDefault();
                const performancePanel = document.getElementById('performance-panel');
                if (performancePanel) {
                    performancePanel.classList.toggle('hidden');
                }
                break;
            case '1':
                event.preventDefault();
                if (this.scene3D) this.scene3D.switchScene('geometric');
                break;
            case '2':
                event.preventDefault();
                if (this.scene3D) this.scene3D.switchScene('particles');
                break;
            case '3':
                event.preventDefault();
                if (this.scene3D) this.scene3D.switchScene('environment');
                break;
            case 'escape':
                event.preventDefault();
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
                break;
        }
    }

    hideLoadingScreen() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }
        
        // Add entrance animations to UI elements
        const uiElements = document.querySelectorAll('.main-nav, .main-content');
        uiElements.forEach((element, index) => {
            setTimeout(() => {
                element.classList.add('fade-in');
            }, index * 200);
        });
    }

    // Cleanup method
    dispose() {
        if (this.scene3D) {
            this.scene3D.dispose();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyboardShortcuts);
        
        console.log('Application disposed');
    }
}

// Add ripple animation CSS
const style = document.createElement('style');
style.textContent = `
    @keyframes ripple {
        to {
            transform: scale(4);
            opacity: 0;
        }
    }
    
    .feature-card.active {
        background: rgba(0, 212, 255, 0.2) !important;
        border-color: var(--primary-color) !important;
    }
`;
document.head.appendChild(style);

// Initialize application when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Add loading class to body
    document.body.classList.add('loading');
    
    // Initialize the 3D application
    window.app3D = new App3D();
    
    // Remove loading class after initialization
    setTimeout(() => {
        document.body.classList.remove('loading');
    }, 2000);
});

// Handle page unload
window.addEventListener('beforeunload', () => {
    if (window.app3D) {
        window.app3D.dispose();
    }
});

// Handle visibility change (tab switching)
document.addEventListener('visibilitychange', () => {
    if (window.app3D && window.app3D.scene3D) {
        if (document.hidden) {
            // Pause animations when tab is not visible
            window.app3D.scene3D.stopAnimation();
        } else {
            // Resume animations when tab becomes visible
            window.app3D.scene3D.startAnimation();
        }
    }
});
    </script>
</html>