<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightning Effect - Fixed</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: black;
        }

        .name {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotateY(0deg);
            color: #00ffff;
            font-size: 5em;
            font-family: 'Poppins', sans-serif;
            font-weight: bold;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ccff, 0 0 80px #0099ff;
            animation: rotate3D 6s linear infinite;
            letter-spacing: 4px;
        }

        @keyframes rotate3D {
            0% {
                transform: translate(-50%, -50%) rotateY(0deg);
            }
            100% {
                transform: translate(-50%, -50%) rotateY(360deg);
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div class="name">Harshitha </div>


    <!-- React and Babel -->
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

    <script type="text/babel">
        const { useRef, useEffect } = React;

        const Lightning = ({ hue = 230, xOffset = 0.0, speed = 1.0, intensity = 1.0, size = 1.0 }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                // Properly resize canvas once on load and on window resize
                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // Create WebGL context
                const gl = canvas.getContext('webgl');
                if (!gl) {
                    console.error('WebGL not supported');
                    return;
                }

                // Vertex shader
                const vertexShaderSource = `
                    attribute vec2 aPosition;
                    void main() {
                        gl_Position = vec4(aPosition, 0.0, 1.0);
                    }
                `;

                // Fragment shader (lightning effect)
                const fragmentShaderSource = `
                    precision mediump float;
                    uniform vec2 iResolution;
                    uniform float iTime;
                    uniform float uHue;
                    uniform float uXOffset;
                    uniform float uSpeed;
                    uniform float uIntensity;
                    uniform float uSize;

                    #define OCTAVE_COUNT 10

                    vec3 hsv2rgb(vec3 c) {
                        vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
                        return c.z * mix(vec3(1.0), rgb, c.y);
                    }

                    float hash12(vec2 p) {
                        vec3 p3 = fract(vec3(p.xyx) * .1031);
                        p3 += dot(p3, p3.yzx + 33.33);
                        return fract((p3.x + p3.y) * p3.z);
                    }

                    mat2 rotate2d(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat2(c, -s, s, c);
                    }

                    float noise(vec2 p) {
                        vec2 ip = floor(p);
                        vec2 fp = fract(p);
                        float a = hash12(ip);
                        float b = hash12(ip + vec2(1.0, 0.0));
                        float c = hash12(ip + vec2(0.0, 1.0));
                        float d = hash12(ip + vec2(1.0, 1.0));
                        vec2 t = smoothstep(0.0, 1.0, fp);
                        return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);
                    }

                    float fbm(vec2 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        for (int i = 0; i < OCTAVE_COUNT; ++i) {
                            value += amplitude * noise(p);
                            p *= rotate2d(0.45);
                            p *= 2.0;
                            amplitude *= 0.5;
                        }
                        return value;
                    }

                    void main() {
                        vec2 uv = gl_FragCoord.xy / iResolution.xy;
                        uv = 2.0 * uv - 1.0;
                        uv.x *= iResolution.x / iResolution.y;
                        uv.x += uXOffset;

                        // Add FBM distortion
                        uv += 2.0 * fbm(uv * uSize + 0.8 * iTime * uSpeed) - 1.0;

                        // Safe distance (avoid division by zero)
                        float safeDist = max(abs(uv.x), 0.001);

                        vec3 baseColor = hsv2rgb(vec3(uHue / 360.0, 0.7, 0.9));
                        float lightning = pow(1.0 / safeDist, 1.2) * uIntensity;
                        vec3 col = baseColor * lightning;

                        // Final color output
                        gl_FragColor = vec4(col, 1.0);
                    }
                `;

                // Helper to compile shader
                const compileShader = (source, type) => {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        console.error(gl.getShaderInfoLog(shader));
                        return null;
                    }
                    return shader;
                };

                const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
                if (!vertexShader || !fragmentShader) return;

                // Link shaders to program
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error(gl.getProgramInfoLog(program));
                    return;
                }
                gl.useProgram(program);

                // Set up vertex data
                const vertices = new Float32Array([
                    -1, -1, 1, -1, -1, 1,
                    -1, 1, 1, -1, 1, 1
                ]);
                const vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

                const aPosition = gl.getAttribLocation(program, 'aPosition');
                gl.enableVertexAttribArray(aPosition);
                gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

                // Get uniform locations
                const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
                const iTimeLocation = gl.getUniformLocation(program, 'iTime');
                const uHueLocation = gl.getUniformLocation(program, 'uHue');
                const uXOffsetLocation = gl.getUniformLocation(program, 'uXOffset');
                const uSpeedLocation = gl.getUniformLocation(program, 'uSpeed');
                const uIntensityLocation = gl.getUniformLocation(program, 'uIntensity');
                const uSizeLocation = gl.getUniformLocation(program, 'uSize');

                const startTime = performance.now();

                const render = () => {
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    const currentTime = performance.now();
                    gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
                    gl.uniform1f(iTimeLocation, (currentTime - startTime) / 1000.0);
                    gl.uniform1f(uHueLocation, hue);
                    gl.uniform1f(uXOffsetLocation, xOffset);
                    gl.uniform1f(uSpeedLocation, speed);
                    gl.uniform1f(uIntensityLocation, intensity);
                    gl.uniform1f(uSizeLocation, size);

                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    requestAnimationFrame(render);
                };
                requestAnimationFrame(render);

                return () => {
                    window.removeEventListener('resize', resizeCanvas);
                };
            }, []);

            return <canvas ref={canvasRef} style={{ width: "100vw", height: "100vh", display: "block" }} />;
        };

        ReactDOM.render(<Lightning />, document.getElementById('root'));
    </script>
</body>
</html>
