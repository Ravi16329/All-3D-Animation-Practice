<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Animated World</title>
    <style>
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Arial', sans-serif;
    background: #000;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
}

#container {
    width: 100%;
    height: 100vh;
    position: relative;
}

canvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
}

/* Custom scrollbar styles */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 4px;
    transition: background 0.3s ease;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
}

/* Firefox scrollbar */
* {
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.1);
}

@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}
    </style>
</head>
<body>
    <div id="container"></div>
    <script>
        // Global variables
let scene, camera, renderer, controls;
let sphere, particleSystem, stickFigures = [];
let animationId;

// Initialize the 3D scene
function init() {
    // Create scene
    scene = new THREE.Scene();
    
    // Create camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(5, 5, 5);
    
    // Create renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    document.getElementById('container').appendChild(renderer.domElement);
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    
    const pointLight1 = new THREE.PointLight(0xffffff, 1, 100);
    pointLight1.position.set(10, 10, 10);
    scene.add(pointLight1);
    
    const pointLight2 = new THREE.PointLight(0x4444ff, 0.5, 100);
    pointLight2.position.set(-10, -10, -10);
    scene.add(pointLight2);
    
    // Create rotating sphere wireframe
    createRotatingSphere();
    
    // Create particle system
    createParticleSystem();
    
    // Create stick figures
    createStickFigures();
    
    // Create starfield background
    createStarfield();
    
    // Add orbit controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    controls.minDistance = 4;
    controls.maxDistance = 15;
    
    // Handle window resize
    window.addEventListener('resize', onWindowResize, false);
    
    // Start animation loop
    animate();
}

// Create the main rotating sphere
function createRotatingSphere() {
    const geometry = new THREE.SphereGeometry(3, 32, 32);
    const material = new THREE.MeshBasicMaterial({
        color: 0x4444ff,
        wireframe: true,
        transparent: true,
        opacity: 0.3
    });
    sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);
}

// Create particle system
function createParticleSystem() {
    const particleCount = 800;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        // Generate random positions inside sphere
        const phi = Math.random() * Math.PI * 2;
        const costheta = Math.random() * 2 - 1;
        const u = Math.random();
        
        const theta = Math.acos(costheta);
        const r = 3 * Math.cbrt(u) * 0.9; // Keep particles slightly inside sphere
        
        positions[i * 3] = r * Math.sin(theta) * Math.cos(phi);
        positions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
        positions[i * 3 + 2] = r * Math.cos(theta);
        
        // Random grey/black colors
        const grayValue = Math.random() * 0.4 + 0.1;
        colors[i * 3] = grayValue;
        colors[i * 3 + 1] = grayValue;
        colors[i * 3 + 2] = grayValue;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const material = new THREE.PointsMaterial({
        size: 0.02,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true
    });
    
    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
}

// Create stick figures
function createStickFigures() {
    const positions = [
        [1.5, 0, 1.5],
        [-1.5, 1, -1],
        [0, -1.5, 2]
    ];
    
    const rotationSpeeds = [0.02, 0.015, 0.025];
    
    positions.forEach((position, index) => {
        const stickFigure = createStickFigure(position);
        stickFigure.userData = { 
            rotationSpeed: rotationSpeeds[index],
            originalY: position[1]
        };
        stickFigures.push(stickFigure);
        scene.add(stickFigure);
    });
}

// Create individual stick figure
function createStickFigure(position) {
    const group = new THREE.Group();
    const redMaterial = new THREE.MeshStandardMaterial({ color: 0xff4444 });
    
    // Head
    const headGeometry = new THREE.SphereGeometry(0.15, 8, 8);
    const head = new THREE.Mesh(headGeometry, redMaterial);
    head.position.set(0, 0.8, 0);
    group.add(head);
    
    // Body
    const bodyGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8);
    const body = new THREE.Mesh(bodyGeometry, redMaterial);
    body.position.set(0, 0.3, 0);
    group.add(body);
    
    // Left Arm
    const armGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 6);
    const leftArm = new THREE.Mesh(armGeometry, redMaterial);
    leftArm.position.set(-0.3, 0.5, 0);
    leftArm.rotation.z = Math.PI / 6;
    group.add(leftArm);
    
    // Right Arm
    const rightArm = new THREE.Mesh(armGeometry, redMaterial);
    rightArm.position.set(0.3, 0.5, 0);
    rightArm.rotation.z = -Math.PI / 6;
    group.add(rightArm);
    
    // Left Leg
    const legGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 6);
    const leftLeg = new THREE.Mesh(legGeometry, redMaterial);
    leftLeg.position.set(-0.15, -0.3, 0);
    leftLeg.rotation.z = Math.PI / 12;
    group.add(leftLeg);
    
    // Right Leg
    const rightLeg = new THREE.Mesh(legGeometry, redMaterial);
    rightLeg.position.set(0.15, -0.3, 0);
    rightLeg.rotation.z = -Math.PI / 12;
    group.add(rightLeg);
    
    group.position.set(position[0], position[1], position[2]);
    
    return group;
}

// Create starfield background
function createStarfield() {
    const starCount = 5000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(starCount * 3);
    
    for (let i = 0; i < starCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 200;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.5,
        transparent: true,
        opacity: 0.8
    });
    
    const stars = new THREE.Points(geometry, material);
    scene.add(stars);
}

// Animation loop
function animate() {
    animationId = requestAnimationFrame(animate);
    
    const time = Date.now() * 0.001;
    
    // Rotate main sphere
    if (sphere) {
        sphere.rotation.y += 0.005;
        sphere.rotation.x += 0.002;
    }
    
    // Rotate particle system
    if (particleSystem) {
        particleSystem.rotation.y += 0.01;
        particleSystem.rotation.x += 0.005;
    }
    
    // Animate stick figures
    stickFigures.forEach((figure, index) => {
        if (figure.userData) {
            // Rotate around Y axis
            figure.rotation.y += figure.userData.rotationSpeed;
            // Add bobbing motion
            figure.position.y = figure.userData.originalY + Math.sin(time * 2 + index) * 0.1;
        }
    });
    
    // Update controls
    if (controls) {
        controls.update();
    }
    
    // Render the scene
    renderer.render(scene, camera);
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Cleanup function
function cleanup() {
    if (animationId) {
        cancelAnimationFrame(animationId);
    }
    
    if (renderer) {
        renderer.dispose();
    }
    
    // Dispose geometries and materials
    scene.traverse((object) => {
        if (object.geometry) {
            object.geometry.dispose();
        }
        if (object.material) {
            if (Array.isArray(object.material)) {
                object.material.forEach(material => material.dispose());
            } else {
                object.material.dispose();
            }
        }
    });
}

// Handle page visibility change
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
    } else {
        animate();
    }
});

// Handle page unload
window.addEventListener('beforeunload', cleanup);

// Initialize when page loads
window.addEventListener('load', init);
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="script.js"></script>
</body>
</html>